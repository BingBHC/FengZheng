<!DOCTYPE html>
<html>
<head>
    <title>我的视频网站</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            font-family: sans-serif;
        }
        
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .content {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 40px 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            background-color: rgba(0, 0, 0, 0.4);
            display: inline-block;
            padding: 10px 25px;
            border-radius: 10px;
        }
        
        p {
            color: white;
            font-size: 1.2em;
            margin: 15px 0;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.7);
            background-color: rgba(0, 0, 0, 0.3);
            display: inline-block;
            padding: 8px 15px;
            border-radius: 8px;
        }
        
        video {
            max-width: 90%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.3);
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <!-- WebGL背景画布 -->
    <canvas id="background-canvas"></canvas>
    
    <!-- 内容区域 -->
    <div class="content">
        <h1>联系微信：xswlan2022</h1>
        <p>作品如下</p>

        <!-- 视频播放器 -->
        <video controls autoplay loop muted playsinline>
            <source src="VFX_A.mp4" type="video/mp4">
            您的浏览器不支持HTML5视频标签。
        </video>

        <p>谢谢观看</p>
    </div>

    <script>
        // 获取Canvas和WebGL上下文
        const canvas = document.getElementById('background-canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('您的浏览器不支持WebGL，无法显示动态背景效果');
        } else {
            // 调整Canvas大小
            function resizeCanvas() {
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = window.innerHeight * window.devicePixelRatio;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // 顶点着色器代码
            const vertexShaderSource = `
                attribute vec2 a_position;
                varying vec2 v_uv;
                void main() {
                    v_uv = a_position * 0.5 + 0.5;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // 您最初提供的完整着色器代码（未修改颜色映射）
            const fragmentShaderSource = `
                precision highp float;
                uniform float iTime;
                uniform vec2 iResolution;
                varying vec2 v_uv;
                
                // 您最初提供的颜色映射函数（产生紫色调）
                float colormap_red(float x) {
                    if (x < 0.0) {
                        return 54.0 / 255.0;
                    } else if (x < 20049.0 / 82979.0) {
                        return (829.79 * x + 54.51) / 255.0;
                    } else {
                        return 1.0;
                    }
                }
                
                float colormap_green(float x) {
                    if (x < 20049.0 / 82979.0) {
                        return 0.0;
                    } else if (x < 327013.0 / 810990.0) {
                        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;
                    } else if (x <= 1.0) {
                        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;
                    } else {
                        return 1.0;
                    }
                }
                
                float colormap_blue(float x) {
                    if (x < 0.0) {
                        return 54.0 / 255.0;
                    } else if (x < 7249.0 / 82979.0) {
                        return (829.79 * x + 54.51) / 255.0;
                    } else if (x < 20049.0 / 82979.0) {
                        return 127.0 / 255.0;
                    } else if (x < 327013.0 / 810990.0) {
                        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;
                    } else {
                        return 1.0;
                    }
                }
                
                vec4 colormap(float x) {
                    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
                }
                
                float rand(vec2 n) { 
                    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
                }
                
                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 u = fract(p);
                    u = u*u*(3.0-2.0*u);
                    
                    float res = mix(
                        mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                        mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), 
                        u.y
                    );
                    return res*res;
                }
                
                const mat2 mtx = mat2(0.80, 0.60, -0.60, 0.80);
                
                float fbm(vec2 p) {
                    float f = 0.0;
                    
                    f += 0.500000 * noise(p + iTime);
                    p = mtx * p * 2.02;
                    f += 0.031250 * noise(p);
                    p = mtx * p * 2.01;
                    f += 0.250000 * noise(p);
                    p = mtx * p * 2.03;
                    f += 0.125000 * noise(p);
                    p = mtx * p * 2.01;
                    f += 0.062500 * noise(p);
                    p = mtx * p * 2.04;
                    f += 0.015625 * noise(p + sin(iTime));
                    
                    return f / 0.96875;
                }
                
                float pattern(vec2 p) {
                    return fbm(p + fbm(p + fbm(p)));
                }
                
                void main() {
                    vec2 uv = v_uv * iResolution.xy / iResolution.x;
                    float shade = pattern(uv);
                    vec4 color = vec4(colormap(shade).rgb, shade * 0.7);
                    
                    // 增加中心区域的亮度，使内容更易读
                    vec2 centerVec = uv - vec2(0.5 * iResolution.x / iResolution.y, 0.5);
                    float centerDist = length(centerVec);
                    float vignette = 1.0 - smoothstep(0.3, 1.2, centerDist);
                    color.rgb *= 0.8 + 0.4 * vignette;
                    
                    gl_FragColor = color;
                }
            `;
            
            // 编译着色器
            function compileShader(gl, source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            
            // 创建着色器程序
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('程序链接错误:', gl.getProgramInfoLog(program));
            }
            
            gl.useProgram(program);
            
            // 设置顶点数据
            const vertices = new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]);
            
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // 获取uniform位置
            const iTimeLocation = gl.getUniformLocation(program, "iTime");
            const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
            
            // 动画循环
            let startTime = Date.now();
            
            function render() {
                const currentTime = Date.now();
                const elapsedTime = (currentTime - startTime) / 1000.0;
                
                gl.uniform1f(iTimeLocation, elapsedTime);
                gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                requestAnimationFrame(render);
            }
            
            render();
        }
    </script>
</body>
</html>
