<!DOCTYPE html>
<html>
<head>
    <title>我的视频网站</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            font-family: sans-serif;
            background-color: #000;
        }
        
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .content {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #ffffff;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(100, 150, 255, 0.7);
            background-color: rgba(0, 20, 40, 0.6);
            display: block;
            padding: 15px 30px;
            border-radius: 10px;
            margin-left: auto;
            margin-right: auto;
            width: fit-content;
        }
        
        .subtitle {
            color: #e6f0ff;
            font-size: 1.4em;
            margin-top: 0;
            margin-bottom: 30px;
            text-shadow: 0 0 8px rgba(80, 140, 255, 0.6);
            background-color: rgba(0, 25, 50, 0.5);
            display: block;
            padding: 12px 25px;
            border-radius: 8px;
            margin-left: auto;
            margin-right: auto;
            width: fit-content;
        }
        
        video {
            max-width: 80%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(0, 100, 255, 0.4);
            border: 2px solid rgba(100, 180, 255, 0.3);
            background-color: rgba(0, 0, 0, 0.5);
            margin: 30px 0;
        }
        
        .ending {
            color: #e6f0ff;
            font-size: 1.3em;
            margin-top: 20px;
            text-shadow: 0 0 8px rgba(80, 140, 255, 0.6);
            background-color: rgba(0, 25, 50, 0.5);
            display: inline-block;
            padding: 12px 25px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <!-- WebGL背景画布 -->
    <canvas id="background-canvas"></canvas>
    
    <!-- 内容区域 -->
    <div class="content">
        <h1>联系微信：xswlan2022</h1>
        <p class="subtitle">作品如下</p>

        <!-- 视频播放器 -->
        <video controls autoplay loop muted playsinline>
            <source src="VFX_A.mp4" type="video/mp4">
            您的浏览器不支持HTML5视频标签。
        </video>

        <p class="ending">谢谢观看</p>
    </div>

    <script>
        const canvas = document.getElementById('background-canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('您的浏览器不支持WebGL，无法显示动态背景效果');
        } else {
            function resizeCanvas() {
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = window.innerHeight * window.devicePixelRatio;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            const vertexShaderSource = `
                attribute vec2 a_position;
                varying vec2 v_uv;
                void main() {
                    v_uv = a_position * 0.5 + 0.5;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // 修改后的片段着色器 - 亮蓝色，密集动态效果
            const fragmentShaderSource = `
                precision highp float;
                uniform float iTime;
                uniform vec2 iResolution;
                varying vec2 v_uv;
                
                // 亮蓝色色彩映射
                float colormap_red(float x) {
                    // 减少红色，仅在亮部有少许
                    return x * 0.2;
                }
                
                float colormap_green(float x) {
                    // 中等绿色成分，与蓝色形成青蓝色调
                    return x * 0.5 + 0.2;
                }
                
                float colormap_blue(float x) {
                    // 高亮度蓝色，形成亮蓝色
                    return x * 0.9 + 0.3;
                }
                
                vec4 colormap(float x) {
                    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
                }
                
                float rand(vec2 n) { 
                    return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                // 改进的噪声函数，增加细节
                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 u = fract(p);
                    u = u*u*(3.0-2.0*u);
                    
                    float res = mix(
                        mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                        mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), 
                        u.y
                    );
                    return res;
                }
                
                const mat2 mtx = mat2(0.80, 0.60, -0.60, 0.80);
                
                // 增强的fbm函数 - 增加更多层次，提高密度
                float fbm(vec2 p) {
                    float f = 0.0;
                    float amplitude = 0.5;
                    
                    // 增加更多噪波层次，提高密度和动态感
                    f += amplitude * noise(p + iTime * 0.05);
                    p = mtx * p * 2.0;
                    amplitude *= 0.5;
                    
                    f += amplitude * noise(p + iTime * 0.08);
                    p = mtx * p * 2.1;
                    amplitude *= 0.6;
                    
                    f += amplitude * noise(p + iTime * 0.12);
                    p = mtx * p * 2.2;
                    amplitude *= 0.6;
                    
                    f += amplitude * noise(p + iTime * 0.15);
                    p = mtx * p * 2.3;
                    amplitude *= 0.7;
                    
                    f += amplitude * noise(p + iTime * 0.18);
                    
                    return f / 1.2;
                }
                
                // 更复杂的pattern函数，增加视觉密度
                float pattern(vec2 p) {
                    float scale = 2.0;
                    p *= scale;
                    
                    float value = 0.0;
                    float amplitude = 1.0;
                    
                    // 多重fbm叠加，增加密度
                    for (int i = 0; i < 3; i++) {
                        value += amplitude * fbm(p);
                        p = mtx * p * 1.8 + vec2(0.5, 0.5);
                        amplitude *= 0.6;
                    }
                    
                    return value / 1.5;
                }
                
                void main() {
                    vec2 uv = v_uv * iResolution.xy / iResolution.x;
                    
                    // 调整UV缩放，使噪波更密集
                    uv *= 3.0;
                    
                    float shade = pattern(uv + vec2(iTime * 0.03, iTime * 0.02));
                    
                    // 增强亮蓝色输出
                    vec4 color = vec4(colormap(shade).rgb, 1.0);
                    
                    // 提高整体亮度和饱和度
                    color.rgb *= 1.3;
                    
                    // 增强蓝色成分
                    color.b = min(1.0, color.b * 1.5);
                    
                    // 增加对比度，使亮蓝色更突出
                    float contrast = 1.4;
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // 发光效果
                    float glow = shade * 0.8;
                    color.rgb += vec3(0.2, 0.4, 0.8) * glow * 0.5;
                    
                    // 降低暗部，增强对比
                    float brightness = (color.r + color.g + color.b) / 3.0;
                    if (brightness < 0.3) {
                        color.rgb *= 0.5;
                    }
                    
                    gl_FragColor = color;
                }
            `;
            
            function compileShader(gl, source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('程序链接错误:', gl.getProgramInfoLog(program));
            }
            
            gl.useProgram(program);
            
            const vertices = new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]);
            
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            const iTimeLocation = gl.getUniformLocation(program, "iTime");
            const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
            
            let startTime = Date.now();
            
            function render() {
                const currentTime = Date.now();
                const elapsedTime = (currentTime - startTime) / 1000.0;
                
                gl.uniform1f(iTimeLocation, elapsedTime);
                gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                requestAnimationFrame(render);
            }
            
            render();
        }
    </script>
</body>
</html>
