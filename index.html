<!DOCTYPE html>
<html>
<head>
    <title>我的视频网站</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            font-family: sans-serif;
            background-color: #000; /* 纯黑色底色 */
        }
        
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .content {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #e8f4ff; /* 更亮的文字颜色提高对比度 */
            font-size: 2.5em;
            margin-bottom: 10px; /* 减少与下方段落的间距 */
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.9);
            background-color: rgba(0, 10, 30, 0.6); /* 深蓝色半透明背景 */
            display: block; /* 修正：确保独占一行 */
            padding: 15px 30px;
            border-radius: 10px;
            margin-left: auto;
            margin-right: auto;
            width: fit-content;
        }
        
        .subtitle {
            color: #d0e5ff;
            font-size: 1.4em;
            margin-top: 0; /* 移除顶部边距 */
            margin-bottom: 30px;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8);
            background-color: rgba(0, 15, 40, 0.5);
            display: block; /* 修正：确保独占一行 */
            padding: 12px 25px;
            border-radius: 8px;
            margin-left: auto;
            margin-right: auto;
            width: fit-content;
        }
        
        video {
            max-width: 80%; /* 增大至页面宽度的80% */
            height: auto;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            border: 3px solid rgba(100, 150, 255, 0.15); /* 深蓝色边框 */
            background-color: rgba(0, 0, 0, 0.5);
            margin: 30px 0;
        }
        
        .ending {
            color: #d0e5ff;
            font-size: 1.3em;
            margin-top: 20px;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8);
            background-color: rgba(0, 15, 40, 0.5);
            display: inline-block;
            padding: 12px 25px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <!-- WebGL背景画布 -->
    <canvas id="background-canvas"></canvas>
    
    <!-- 内容区域 -->
    <div class="content">
        <h1>联系微信：xswlan2022</h1>
        <p class="subtitle">作品如下</p> <!-- 使用独立class确保两行显示 -->

        <!-- 视频播放器 -->
        <video controls autoplay loop muted playsinline>
            <source src="VFX_A.mp4" type="video/mp4">
            您的浏览器不支持HTML5视频标签。
        </video>

        <p class="ending">谢谢观看</p>
    </div>

    <script>
        const canvas = document.getElementById('background-canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('您的浏览器不支持WebGL，无法显示动态背景效果');
        } else {
            function resizeCanvas() {
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = window.innerHeight * window.devicePixelRatio;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            const vertexShaderSource = `
                attribute vec2 a_position;
                varying vec2 v_uv;
                void main() {
                    v_uv = a_position * 0.5 + 0.5;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // 修改后的片段着色器 - 深蓝色主题
            const fragmentShaderSource = `
                precision highp float;
                uniform float iTime;
                uniform vec2 iResolution;
                varying vec2 v_uv;
                
                // 修改色彩映射为深蓝色系
                float colormap_red(float x) {
                    // 大幅减少红色成分
                    return 0.0;
                }
                
                float colormap_green(float x) {
                    // 减少绿色成分，仅在中间有少量
                    if (x < 0.6) {
                        return 0.0;
                    } else {
                        return (x - 0.6) * 0.5;
                    }
                }
                
                float colormap_blue(float x) {
                    // 增强蓝色成分，形成深蓝色
                    if (x < 0.3) {
                        return x * 0.5 + 0.1;
                    } else if (x < 0.7) {
                        return x * 0.7 + 0.2;
                    } else {
                        return x * 0.5 + 0.3;
                    }
                }
                
                vec4 colormap(float x) {
                    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
                }
                
                float rand(vec2 n) { 
                    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
                }
                
                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 u = fract(p);
                    u = u*u*(3.0-2.0*u);
                    
                    float res = mix(
                        mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                        mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), 
                        u.y
                    );
                    return res*res;
                }
                
                const mat2 mtx = mat2(0.80, 0.60, -0.60, 0.80);
                
                float fbm(vec2 p) {
                    float f = 0.0;
                    
                    // 所有iTime乘以0.02，速度降至1/50
                    f += 0.500000 * noise(p + iTime * 0.02);
                    p = mtx * p * 2.02;
                    f += 0.031250 * noise(p);
                    p = mtx * p * 2.01;
                    f += 0.250000 * noise(p);
                    p = mtx * p * 2.03;
                    f += 0.125000 * noise(p);
                    p = mtx * p * 2.01;
                    f += 0.062500 * noise(p);
                    p = mtx * p * 2.04;
                    f += 0.015625 * noise(p + sin(iTime * 0.02));
                    
                    return f / 0.96875;
                }
                
                float pattern(vec2 p) {
                    return fbm(p + fbm(p + fbm(p)));
                }
                
                void main() {
                    vec2 uv = v_uv * iResolution.xy / iResolution.x;
                    float shade = pattern(uv);
                    
                    // 调整颜色输出：深蓝色噪波 + 纯黑底色
                    vec4 color = vec4(colormap(shade).rgb, 1.0);
                    
                    // 降低整体亮度，突出深蓝色
                    color.rgb *= 0.5;
                    
                    // 增加蓝色成分
                    color.b = min(1.0, color.b * 1.3);
                    
                    // 强化黑色背景：使暗部更暗
                    float brightness = (color.r + color.g + color.b) / 3.0;
                    if (brightness < 0.4) {
                        color.rgb *= 0.4;
                    }
                    
                    // 增加中心区域的可见度
                    vec2 centerVec = uv - vec2(0.5 * iResolution.x / iResolution.y, 0.5);
                    float centerDist = length(centerVec);
                    float vignette = 1.0 - smoothstep(0.3, 1.0, centerDist);
                    color.rgb *= 0.7 + 0.3 * vignette;
                    
                    gl_FragColor = color;
                }
            `;
            
            function compileShader(gl, source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('程序链接错误:', gl.getProgramInfoLog(program));
            }
            
            gl.useProgram(program);
            
            const vertices = new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]);
            
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            const iTimeLocation = gl.getUniformLocation(program, "iTime");
            const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
            
            let startTime = Date.now();
            
            function render() {
                const currentTime = Date.now();
                const elapsedTime = (currentTime - startTime) / 1000.0;
                
                gl.uniform1f(iTimeLocation, elapsedTime);
                gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                
                gl.clearColor(0, 0, 0, 1); // 纯黑色清除颜色
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                requestAnimationFrame(render);
            }
            
            render();
        }
    </script>
</body>
</html>
