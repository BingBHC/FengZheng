<!DOCTYPE html>
<html>
<head>
    <title>怀化市丰正科技有限责任公司</title>
    <style>
        /* 基础布局样式 - 保持与您要求一致 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: sans-serif;
            overflow-x: hidden; /* 防止横向滚动 */
        }
        
        /* 动态背景画布 */
        #dynamic-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* 置于所有内容下方 */
            display: block;
        }
        
        /* 内容容器 - 保持居中、响应式 */
        .content-container {
            position: relative; /* 使内容层浮于背景之上 */
            z-index: 1;
            text-align: center;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* 您的原始样式保持不变 */
        h1 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
            background-color: rgba(0, 0, 0, 0.5); /* 半透明背景确保文字在动态图上可读 */
            display: inline-block;
            padding: 15px 30px;
            border-radius: 10px;
        }
        
        .subtitle {
            color: #eee;
            font-size: 1.4em;
            margin: 10px 0 30px 0;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.7);
            background-color: rgba(0, 0, 0, 0.4);
            display: inline-block;
            padding: 10px 20px;
            border-radius: 8px;
        }
        
        video {
            max-width: 90%; /* 保持您要求的90%宽度 */
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.15);
            background-color: rgba(0, 0, 0, 0.3);
            margin: 20px 0;
        }
        
        .ending {
            color: #eee;
            font-size: 1.3em;
            margin-top: 20px;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.7);
            background-color: rgba(0, 0, 0, 0.4);
            display: inline-block;
            padding: 10px 20px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <!-- 动态背景层 -->
    <canvas id="dynamic-bg"></canvas>
    
    <!-- 您的内容层 - 布局与之前完全一致 -->
    <div class="content-container">
        <h1>联系邮箱:2235510037@qq.com</h1>
        <p class="subtitle">作品</p>

        <!-- 视频播放器 -->
        <video controls autoplay loop muted playsinline>
            <source src="VFX_A.mp4" type="video/mp4">
            您的浏览器不支持HTML5视频标签。
        </video>

        <p class="ending">谢谢观看</p>
    </div>

    <script>
        // 初始化WebGL背景
        const canvas = document.getElementById('dynamic-bg');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            console.warn('浏览器不支持WebGL，将显示静态背景');
            canvas.style.backgroundColor = '#1a0a2a'; // WebGL不可用时显示的备用深紫色背景
        } else {
            // 调整Canvas尺寸以匹配窗口
            function resizeCanvas() {
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = window.innerHeight * window.devicePixelRatio;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // 顶点着色器
            const vertexShaderSource = `
                attribute vec2 a_position;
                varying vec2 v_uv;
                void main() {
                    v_uv = a_position * 0.5 + 0.5;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;
            
            // 片段着色器 - 使用最初产生紫色效果的原始代码
            const fragmentShaderSource = `
                precision highp float;
                uniform float iTime;
                uniform vec2 iResolution;
                varying vec2 v_uv;
                
                // 原始颜色映射函数（产生紫色调）
                float colormap_red(float x) {
                    if (x < 0.0) {
                        return 54.0 / 255.0;
                    } else if (x < 20049.0 / 82979.0) {
                        return (829.79 * x + 54.51) / 255.0;
                    } else {
                        return 1.0;
                    }
                }
                
                float colormap_green(float x) {
                    if (x < 20049.0 / 82979.0) {
                        return 0.0;
                    } else if (x < 327013.0 / 810990.0) {
                        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;
                    } else if (x <= 1.0) {
                        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;
                    } else {
                        return 1.0;
                    }
                }
                
                float colormap_blue(float x) {
                    if (x < 0.0) {
                        return 54.0 / 255.0;
                    } else if (x < 7249.0 / 82979.0) {
                        return (829.79 * x + 54.51) / 255.0;
                    } else if (x < 20049.0 / 82979.0) {
                        return 127.0 / 255.0;
                    } else if (x < 327013.0 / 810990.0) {
                        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;
                    } else {
                        return 1.0;
                    }
                }
                
                vec4 colormap(float x) {
                    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
                }
                
                float rand(vec2 n) { 
                    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
                }
                
                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 u = fract(p);
                    u = u*u*(3.0-2.0*u);
                    
                    float res = mix(
                        mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                        mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), 
                        u.y
                    );
                    return res*res;
                }
                
                const mat2 mtx = mat2(0.80, 0.60, -0.60, 0.80);
                
                float fbm(vec2 p) {
                    float f = 0.0;
                    
                    f += 0.500000 * noise(p + iTime);
                    p = mtx * p * 2.02;
                    f += 0.031250 * noise(p);
                    p = mtx * p * 2.01;
                    f += 0.250000 * noise(p);
                    p = mtx * p * 2.03;
                    f += 0.125000 * noise(p);
                    p = mtx * p * 2.01;
                    f += 0.062500 * noise(p);
                    p = mtx * p * 2.04;
                    f += 0.015625 * noise(p + sin(iTime));
                    
                    return f / 0.96875;
                }
                
                float pattern(vec2 p) {
                    return fbm(p + fbm(p + fbm(p)));
                }
                
                void main() {
                    vec2 uv = v_uv * iResolution.xy / iResolution.x;
                    float shade = pattern(uv);
                    vec4 color = vec4(colormap(shade).rgb, shade * 0.7);
                    
                    // 使中心区域稍亮，确保内容可读性
                    vec2 centerVec = uv - vec2(0.5 * iResolution.x / iResolution.y, 0.5);
                    float centerDist = length(centerVec);
                    float vignette = 1.0 - smoothstep(0.3, 1.2, centerDist);
                    color.rgb *= 0.8 + 0.4 * vignette;
                    
                    gl_FragColor = color;
                }
            `;
            
            // 编译着色器
            function compileShader(gl, source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }
            
            // 创建着色器程序
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            
            if (vertexShader && fragmentShader) {
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    gl.useProgram(program);
                    
                    // 设置顶点数据
                    const vertices = new Float32Array([
                        -1, -1, 1, -1, -1, 1,
                        -1, 1, 1, -1, 1, 1
                    ]);
                    
                    const vertexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                    
                    const positionAttr = gl.getAttribLocation(program, "a_position");
                    gl.enableVertexAttribArray(positionAttr);
                    gl.vertexAttribPointer(positionAttr, 2, gl.FLOAT, false, 0, 0);
                    
                    // 获取并设置uniform变量
                    const iTimeLocation = gl.getUniformLocation(program, "iTime");
                    const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
                    
                    let startTime = Date.now();
                    
                    // 渲染循环
                    function render() {
                        const currentTime = Date.now();
                        const elapsedTime = (currentTime - startTime) / 1000.0;
                        
                        gl.uniform1f(iTimeLocation, elapsedTime);
                        gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                        
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        
                        requestAnimationFrame(render);
                    }
                    
                    render();
                }
            }
        }
    </script>
</body>
</html>
